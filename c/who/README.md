# 文件的读写  
# 知识点
这一章介绍了在Unix下开发的通常流程。具体如下：  
1. 使用`man`查找相关命令的手册。  
2. 根据手册中的描述找到相关的头文件。  
3. 在头文件中找到与之相关的数据结构。  
4. 根据要实现的功能构思程序基本流程，并列举可能用到的系统功能。  
5. 使用`man -k <keyword>`根据需要的功能查找系统调用。  
6. 使用系统调用编写程序，此过程中可能需要上网搜索其他资料。  
7. 比较实现的程序与系统自带程序的输出结果。  
8. 如结果不同，则需要再次查阅手册以及相关头文件，在头文件中寻找进一步信息。否则，进一步考虑如何提高程序性能。  
9. 提高性能时需进一步理解相关概念，掌握常用的方法。  
10. 得到一个功能正确，性能基本可以的程序，完成开发。  

## 功能分析  
要编写的who程序应该具有以下的功能：  
1. 能够读取相应的文件，并将结果显示出来。  
2. 显示的结果中只应该包含对应真实的用户的记录，并且能够正确地展示时间。  
3. 利用缓冲提高程序的性能。  
4. 编写注销函数，使其能正确修改相应的文件。注销之后，who可以正确地展示变化后的文件内容。  
5. 能够正确地处理系统调用可能产生的错误。  
6. 提供额外的接口，可以检查utmp文件内容的变化，展示utmp记录的所有字段，并且可以通过参数指定要读取的文件，进而用其检查wtmp的内容。  

## 编程中的问题  
1. read和fread 
第一个问题是既然要读文件，那么`read`和`fread`有什么区别，应该使用哪一个？搜索后发现，读文件实际上可能涉及到两层缓冲。第一层是用户程序设置的缓冲，作用是减少系统调用的次数。第二层缓冲是内核使用的缓冲，它一般会把磁盘上的文件放到内存中内核的缓冲区进行缓存。作为系统调用的`read`只有内核层的缓冲，而作为标准函数的`fread`还具有用户空间的缓冲。  

2. ssize_t read(int fd, void \*buf, size_t count)  
	* 关于ssize_t，这个类型被用于需要返回-1的情况，它和int之间的大小没有保证，通常它会比int大，它的范围一定包含[-1, SSIZE_MAX]，上界是取决于实现的。这个类型是POSIX标准定义的，意味着它并不可移植。
	* read在NFS文件系统上，连续读取少量数据，只会在第一次更新文件的时间戳。因为大多数NFS系统会将更新访问时间的任务留给服务器端，而客户端从客户的缓存中读入后就会返回。Unix下可以禁止客户端的缓存，但这样会极大增加服务器的负荷。  
	* 当count为0时，可以通过检测返回值来判断是否有错误出现。   
3. utmp, btmp, wtmp  
	* utmp记录的是当前正在使用系统的用户的信息，但是有些用户可能没有被记录，因为有些程序不生成utmp记录。utmp不能被其他用户类别修改，因为有些系统程序需要依赖它的完整性。Linux上utmp必须存在，所以如果要禁止`who`指令读取它，应该通过修改权限来实现。
	* wtmp则记录了系统用户登入、登出的记录，`last`指令会读取它。它的格式和utmp一样，如果用户名为空那么表示关联的终端已经登出。如果用户名是reboot或者shutdown并且终端名是`~`，那么代表系统关机或者重启的记录。如果文件被删除，那么相关功能被关闭。  
	* btmp被`lastb`使用，记录了所有失败的登录尝试。  
4. \#ifdef只测试宏是否被#define定义过，即使使用形如`#define A`形式也会返回真，但是\#if则需要定义为非零值  
5. 系统中utmp,wtmp的路径可以通过宏UTMP_FILE/UTMP_FILENAME, WTMP_FILE/WTMP_FILENAME获得。
6. struct utmp  
结构体中定义了关于用户登录时的信息。
	* `ut_line`是登录时的设备名，如`tty1`, `pts/0`等。  
	* `ut_user`是用户名，`ut_host`是主机名，经过测试在很多情况下，它可能是空或者就是字符串形式的用户登录时的ip地址，也存在是主机名的情况。    
	* `ut_addr_v6`则是用户登录时使用的ip地址，要注意的是这里定义的128字节长度的地址，IPv4地址只是用了第一个字节。  
	* `ut_tv`是登录时的时间，格式是从1970年1月1日开始后经过的时间。这里要注意它和另外一个域`ut_session`在32位和64位系统中都是等大小的，所以通过`#ifdef __WORDSIZE_TIME64_COMPAT32`宏判断实现不同的具体类型。
